<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模板</title>
      <link href="/2020/06/27/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/06/27/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/snow_zhao/img/raw/master/img/image-20200627224317586.png" alt=""></p><p>关注公众号回复关键词“everything”即可获取软件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑软件推荐第一弹——everything</title>
      <link href="/2020/06/27/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E7%AC%AC%E4%B8%80%E5%BC%B9%E2%80%94%E2%80%94everything/"/>
      <url>/2020/06/27/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E7%AC%AC%E4%B8%80%E5%BC%B9%E2%80%94%E2%80%94everything/</url>
      
        <content type="html"><![CDATA[<p>电脑系统自带文件管理器的文件搜索速度一直为人所诟病，我们往往需要花上很长时间来找到想找的文件。</p><p>今天给大家推荐一款文件搜索“快如闪电”的软件——everything。</p><p>它在全新安装的 Windows 10 (大约 120,000 个文件) 仅需 1 秒即可索引完成。索引 1,000,000 个文件只需要大约 1 分钟。</p><p>除了速度快以外，它还有很多其他的优点。</p><ol><li><p>丰富的高级搜索功能</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200627212919090.png" alt="image-20200627212919090"></p></li><li><p>支持正则表达式搜索</p></li><li><p>支持根据文件类型进行搜索</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/20200627214016.png" alt="image-20200627214002727"></p></li><li><p>占用系统资源小，不会给电脑带来负担</p><p><img src="https://gitee.com/snow_zhao/img/raw/master/img/image-20200627224317586.png" alt=""></p><p>关注公众号回复关键词“everything”即可获取软件。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PIL库filter</title>
      <link href="/2020/06/24/PIL%E5%BA%93filter/"/>
      <url>/2020/06/24/PIL%E5%BA%93filter/</url>
      
        <content type="html"><![CDATA[<h3 id="1、BLUR-模糊滤波"><a href="#1、BLUR-模糊滤波" class="headerlink" title="1、BLUR: 模糊滤波"></a>1、BLUR: 模糊滤波</h3><h3 id="2、-CONTOUR-轮廓滤波"><a href="#2、-CONTOUR-轮廓滤波" class="headerlink" title="2、 CONTOUR: 轮廓滤波"></a>2、 CONTOUR: 轮廓滤波</h3><h3 id="3、DETAIL-细节增强滤波"><a href="#3、DETAIL-细节增强滤波" class="headerlink" title="3、DETAIL: 细节增强滤波"></a>3、DETAIL: 细节增强滤波</h3><h3 id="4、EDGE-ENHANCE-边缘增强滤波"><a href="#4、EDGE-ENHANCE-边缘增强滤波" class="headerlink" title="4、EDGE_ENHANCE: 边缘增强滤波"></a>4、EDGE_ENHANCE: 边缘增强滤波</h3><h3 id="5、EDGE-ENHANCE-MORE-深度边缘增强滤波"><a href="#5、EDGE-ENHANCE-MORE-深度边缘增强滤波" class="headerlink" title="5、EDGE_ENHANCE_MORE: 深度边缘增强滤波"></a>5、EDGE_ENHANCE_MORE: 深度边缘增强滤波</h3><h3 id="6、EMBOSS-浮雕滤波"><a href="#6、EMBOSS-浮雕滤波" class="headerlink" title="6、EMBOSS: 浮雕滤波"></a>6、EMBOSS: 浮雕滤波</h3><h3 id="7、FIND-EDGES-寻找边缘信息滤波"><a href="#7、FIND-EDGES-寻找边缘信息滤波" class="headerlink" title="7、FIND_EDGES: 寻找边缘信息滤波"></a>7、FIND_EDGES: 寻找边缘信息滤波</h3><h3 id="8、SMOOTH-平滑滤波"><a href="#8、SMOOTH-平滑滤波" class="headerlink" title="8、SMOOTH: 平滑滤波"></a>8、SMOOTH: 平滑滤波</h3><h3 id="9、SMOOTH-MORE-深度平滑滤波"><a href="#9、SMOOTH-MORE-深度平滑滤波" class="headerlink" title="9、SMOOTH_MORE: 深度平滑滤波"></a>9、SMOOTH_MORE: 深度平滑滤波</h3><h3 id="10、SHARPEN-锐化滤波"><a href="#10、SHARPEN-锐化滤波" class="headerlink" title="10、SHARPEN: 锐化滤波"></a>10、SHARPEN: 锐化滤波</h3>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python PIL库</title>
      <link href="/2020/06/23/python-PIL%E5%BA%93/"/>
      <url>/2020/06/23/python-PIL%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="PIL库"><a href="#PIL库" class="headerlink" title="PIL库"></a>PIL库</h1><h3 id="1、导入图片"><a href="#1、导入图片" class="headerlink" title="1、导入图片"></a>1、导入图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">im = Image.open(<span class="string">"1.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者从打开的文件中导入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"1.jpg"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    im.Image.open(fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者读取二进制数据</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">im = Image.open(io.BytesIO(buffer))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者从.tar文件中读取</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> TarIO</span><br><span class="line">fp = TarIO.TarIO(<span class="string">"text.tar"</span>, <span class="string">"1.jpg"</span>)</span><br><span class="line">im = Image.open(fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开失败将出现IOError异常</span></span><br></pre></td></tr></table></figure><h3 id="2、图片信息"><a href="#2、图片信息" class="headerlink" title="2、图片信息"></a>2、图片信息</h3><table><thead><tr><th align="center">属性</th><th align="center">含义</th><th>返回值</th></tr></thead><tbody><tr><td align="center">format</td><td align="center">格式</td><td>图片格式名</td></tr><tr><td align="center">size</td><td align="center">大小</td><td>包含宽度和高度的二元组</td></tr><tr><td align="center">mode</td><td align="center">类型</td><td>“I”:灰度图像”RGB”:真彩色图像”CMYK”:预印图像</td></tr></tbody></table><h3 id="3、Image类方法"><a href="#3、Image类方法" class="headerlink" title="3、Image类方法"></a>3、Image类方法</h3><ul><li><pre><code>im.show()  # 显示图片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.save(filename, mode)  # 保存图片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.transpose(Image.ROTATE_180)  # 旋转180度im.transpose(Image.FLIP_LEFT_RIGHT)  # 左右颠倒out = im.transpose(Image.FLIP_TOP_BOTTOM)  # 上下颠倒<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.resize((128, 128))  # 重新设置大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.rotate(45) # 旋转<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.filter()  #使用过滤器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.point()  # 采用点变换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure>im.merge(mode, RGB)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">### 4、图片格式转换</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 命令行模式下运行程序，sys.argv获取输入的字符串</span><br><span class="line"># 如输入：python convert.py test.jpg</span><br><span class="line"># 则sys.argv[0]为&quot;convert.py&quot;, sys.argv[1]为&quot;test.jpg&quot;</span><br><span class="line"># 输入的&quot;python&quot;不予获取</span><br><span class="line">for infile in sys.argv[1:]:</span><br><span class="line">    f, e &#x3D; os.path.splitext(infile)</span><br><span class="line">    outfile &#x3D; f + &quot;.jpg&quot;</span><br><span class="line">    if infile !&#x3D; outfile:</span><br><span class="line">        try:</span><br><span class="line">            with Image.open(infile) as im:</span><br><span class="line">                im.save(outfile)</span><br><span class="line">                print(&quot;saved&quot;, outfile)</span><br><span class="line">        except IOError:</span><br><span class="line">            print(&quot;cannot convert&quot;, infile)</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="5、创建缩略图"><a href="#5、创建缩略图" class="headerlink" title="5、创建缩略图"></a>5、创建缩略图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = (<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    f, e = os.path.splitext(infile)</span><br><span class="line">    outfile = f + <span class="string">".thumbnail"</span></span><br><span class="line">    <span class="keyword">if</span> infile != outfile:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> Image.open(infile) <span class="keyword">as</span> im:</span><br><span class="line">                im.thumbnail(size)</span><br><span class="line">                im.save(outfile, <span class="string">"JPEG"</span>)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            print(<span class="string">"Cannot create thumbnail for"</span>, infile)</span><br></pre></td></tr></table></figure><h3 id="6、截取图片"><a href="#6、截取图片" class="headerlink" title="6、截取图片"></a>6、截取图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box = (<span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">region = im.crop(box)</span><br></pre></td></tr></table></figure><h3 id="7、粘贴图片"><a href="#7、粘贴图片" class="headerlink" title="7、粘贴图片"></a>7、粘贴图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region = region.transpose(Image.ROTATE_180)</span><br><span class="line">im.paste(region, box)</span><br></pre></td></tr></table></figure><h3 id="8、颜色带"><a href="#8、颜色带" class="headerlink" title="8、颜色带"></a>8、颜色带</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r, g, b = im.split()</span><br><span class="line">im = Image.merge(<span class="string">"RGB"</span>, (b, g, r))</span><br></pre></td></tr></table></figure><h3 id="9、模式变换"><a href="#9、模式变换" class="headerlink" title="9、模式变换"></a>9、模式变换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> Image.open(<span class="string">"1.jpg"</span>) <span class="keyword">as</span> im:</span><br><span class="line">im = im.convert(<span class="string">"L"</span>)</span><br></pre></td></tr></table></figure><h3 id="10、图像处理"><a href="#10、图像处理" class="headerlink" title="10、图像处理"></a>10、图像处理</h3><ul><li><p><code>filter</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter</span><br><span class="line"></span><br><span class="line">out = im.filter(ImageFilter.DETAIL)</span><br></pre></td></tr></table></figure></li><li><p><code>point</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个点的像素都乘以1.2</span></span><br><span class="line">out = im.point(<span class="keyword">lambda</span> i: i * <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure></li><li><p>处理单独的颜色带：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source = im.split()</span><br><span class="line"></span><br><span class="line">R, G, B = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">mask = source[R].point(<span class="keyword">lambda</span> i: i &lt; <span class="number">100</span> <span class="keyword">and</span> <span class="number">255</span>)</span><br><span class="line">out = source[G].point(<span class="keyword">lambda</span> i: i * <span class="number">0.7</span>)</span><br><span class="line">source[G].paste(out, <span class="literal">None</span>, mask)</span><br><span class="line">im = Image.merge(im.mode, source)</span><br></pre></td></tr></table></figure></li></ul><h3 id="11、增强图像"><a href="#11、增强图像" class="headerlink" title="11、增强图像"></a>11、增强图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enh = ImageEnhance.Contrast(im)</span><br><span class="line">enh.enhance(<span class="number">1.3</span>).show(<span class="string">"%30 more contrast"</span>)</span><br></pre></td></tr></table></figure><h3 id="12、图像序列"><a href="#12、图像序列" class="headerlink" title="12、图像序列"></a>12、图像序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Image.open(<span class="string">"1.gif"</span>) <span class="keyword">as</span> im:</span><br><span class="line">    im.seek(<span class="number">1</span>) <span class="comment"># 跳到第二帧</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            im.seek(im.tell()+<span class="number">1</span>)</span><br><span class="line">            im.show()</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 序列读取结束时将返回EOPError异常</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import ImageSequence</span><br><span class="line">for frame in ImageSequence.Iterator(im):</span><br><span class="line">frame.show()</span><br></pre></td></tr></table></figure><h3 id="13、Postscript"><a href="#13、Postscript" class="headerlink" title="13、Postscript"></a>13、Postscript</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, PSDraw</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Image.open(<span class="string">"1.jpg"</span>) <span class="keyword">as</span> im:</span><br><span class="line">    title = <span class="string">"canteen"</span></span><br><span class="line">    box = (<span class="number">1</span>*<span class="number">72</span>, <span class="number">2</span>*<span class="number">72</span>, <span class="number">7</span>*<span class="number">72</span>, <span class="number">10</span>*<span class="number">72</span>)</span><br><span class="line">    ps = PSDraw.PSDraw()</span><br><span class="line">    ps.begin_document(title)</span><br><span class="line"></span><br><span class="line">    ps.image(box, im, <span class="number">75</span>)</span><br><span class="line">    ps.rectangle(box)</span><br><span class="line"></span><br><span class="line">    ps.setfont(<span class="string">"HelveticaNarrow-Bold"</span>, <span class="number">36</span>)</span><br><span class="line">    ps.text((<span class="number">3</span>*<span class="number">72</span>, <span class="number">4</span>*<span class="number">72</span>), title)</span><br><span class="line"></span><br><span class="line">    ps.end_document()</span><br><span class="line">    im.show()</span><br></pre></td></tr></table></figure><h3 id="14、draft模式"><a href="#14、draft模式" class="headerlink" title="14、draft模式"></a>14、draft模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只适用于JPEG和MPO文件</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Image.open(file) <span class="keyword">as</span> im:</span><br><span class="line">    print(<span class="string">"original ="</span>, im.mode, im.size)</span><br><span class="line"></span><br><span class="line">    im.draft(<span class="string">"L"</span>, (<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">    print(<span class="string">"draft ="</span>, im.mode, im.size)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构总结</title>
      <link href="/2020/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Unit-1-绪论"><a href="#Unit-1-绪论" class="headerlink" title="Unit 1 : 绪论"></a>Unit 1 : 绪论</h1><ol><li><p>数据元素是数据的基本单位。一个数据元素可由若干个数据项组成。</p></li><li><p>数据对象是性质相同的数据元素的集合，是数据的一个子集。</p></li><li><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据元素之间的关系称为结构，四类基本结构：</p><ul><li>集合：除了同属一个集合，别无其他关系。</li><li>线性结构：存在一对一的关系。</li><li>树形结构：存在一对多的关系。</li><li>图状结构或网状结构：存在多个对多个的关系。</li></ul></li><li><p>数据结构的形式定义：<code>Data_Structure = (D, S)</code>，其中D是数据元素的有限集，S是D上关系的有限集。</p></li><li><p>数据结构在计算机中的表示称为数据的物理结构，又称为存储结构。数据元素之间的关系在计算机中有顺序映像和非顺序映像两种表示方法，由此得到两种不同的存储结构：顺序存储结构和链式存储结构。</p></li><li><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称，可分为：</p><ul><li>原子类型：例如C语言的基本类型，整型、实型、字符型等等。</li><li>结构类型：如数组。</li></ul></li><li><p>抽象数据类型（ADT）,是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，与其在计算机内部的表示和实现无关。抽象数据类型可分为：</p><ul><li>原子类型</li><li>固定聚合类型</li><li>可变聚合类型</li></ul><p>抽象数据类型可由三元组（D，S，P）表示，D为数据对象，S是D上的关系集，P是对D的基本操作集。</p></li><li><p>多形数据类型是指其值的成分不确定的数据类型。</p></li><li><p>算法是对特定问题求解步骤的一种描述，是指令的有限序列，每条指令表示一个或多个操作。算法的五个重要特性：</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入（0个或多个）</li><li>输出（一个或多个）</li></ul></li><li><p>算法设计的要求：</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>效率和低储存量需求·</li></ul></li><li><p>算法性能分析：</p><ul><li>硬件的速度</li><li>书写程序的语言</li><li>编译程序所生成的目标代码质量</li><li>问题的规模</li></ul></li><li><p>算法的时间复杂度和空间复杂度。</p></li><li><p>数据结构包括数据的逻辑结构(线性、非线性)、存储结构(顺序、链式)和运算集合 3 个部分。</p></li></ol><h1 id="Unit-2-线性表"><a href="#Unit-2-线性表" class="headerlink" title="Unit 2 : 线性表"></a>Unit 2 : 线性表</h1><ol><li><p>线性表是n个数据元素的有限序列。</p></li><li><p>一个数据元素可由若干个数据项组成，在这种情况下常常把数据元素成为记录，含有大量记录的线性表又称文件。</p></li><li><p>线性表的基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L)</span><br><span class="line">DestroyList(&amp;L)</span><br><span class="line">ClearList(&amp;L)</span><br><span class="line">ListEmpty(L)</span><br><span class="line">ListLength(L)</span><br><span class="line">GetElem(L, i, &amp;e)</span><br><span class="line">LocateElem(L, e, compare())</span><br><span class="line">PriorElem(L, cur_e, &amp;pre_e)</span><br><span class="line">NextElem(L, cur_e, &amp;next_e)</span><br><span class="line">ListInsert(&amp;L, i, e)&#x2F;&#x2F;复杂度为O(n)</span><br><span class="line">ListDelete(&amp;L, i, &amp;e)&#x2F;&#x2F;复杂度为O(n)</span><br><span class="line">ListTraverse(L, visit())</span><br></pre></td></tr></table></figure></li><li><p>线性表的顺序存储：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></li><li><p>线性表的链式表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ELemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*List;</span><br></pre></td></tr></table></figure></li><li><p>静态链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">jn</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">&#125;JNode, JList[MAXSIZE];</span><br></pre></td></tr></table></figure></li><li><p>循环链表：链表中最后一个结点指向头结点。</p></li><li><p>双向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dn</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dn</span> *<span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dn</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;DNode,*DList</span><br></pre></td></tr></table></figure></li></ol><h1 id="Unit-3-栈和队列"><a href="#Unit-3-栈和队列" class="headerlink" title="Unit 3 : 栈和队列"></a>Unit 3 : 栈和队列</h1><ol><li><p>栈是限定仅在表尾进行插入或删除的线性表。</p></li><li><p>栈的基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitStack(&amp;S)</span><br><span class="line">DestroyStack(&amp;S)</span><br><span class="line">ClearStack(&amp;S)</span><br><span class="line">StackEmpty(S)</span><br><span class="line">StackLength(S)</span><br><span class="line">GetTop(S, &amp;e)</span><br><span class="line">Push(&amp;S, e)</span><br><span class="line">Pop(&amp;S, &amp;e)</span><br><span class="line">StackTraverse(S, visit())</span><br></pre></td></tr></table></figure></li><li><p>顺序栈：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>&#123;</span></span><br><span class="line">ElemType *top;</span><br><span class="line">ElemType *bottom;</span><br><span class="line"><span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure></li><li><p>栈和递归的实现。</p></li><li><p>队列是一种先进先出的线性表。</p></li><li><p>队列的基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(&amp;Q)</span><br><span class="line">DestroyQueue(&amp;Q)</span><br><span class="line">ClearQueue(&amp;Q)</span><br><span class="line">QueueEmpty(Q)</span><br><span class="line">QueueLength(Q)</span><br><span class="line">GetHead(Q, &amp;e)</span><br><span class="line">EnQueue(&amp;Q, e)</span><br><span class="line">Dequeue(&amp;Q, &amp;e)</span><br><span class="line">QueueTraverse(Q, visit())</span><br></pre></td></tr></table></figure></li><li><p>链队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qn</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qu</span> *<span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;<span class="title">QNode</span>, *<span class="title">QPtr</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">q</span>&#123;</span></span><br><span class="line">QPtr front;</span><br><span class="line">QPtr rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure></li><li><p>循环队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sq</span>&#123;</span></span><br><span class="line">ElemType *base;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue</span><br></pre></td></tr></table></figure></li></ol><h1 id="Unit-4-串"><a href="#Unit-4-串" class="headerlink" title="Unit 4 : 串"></a>Unit 4 : 串</h1><ol><li><p>串是由零个或多个字符组成的有限序列。</p></li><li><p>串中任意个连续的字符组成的子序列称为该串的子串。</p></li><li><p>基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrAssigh(&amp;T, chars)</span><br><span class="line">StrCopy(&amp;T, S)</span><br><span class="line">StrEmpty(S)</span><br><span class="line">StrCompare(S, T)</span><br><span class="line">StrLength(S)</span><br><span class="line">ClearString(&amp;S)</span><br><span class="line">Concat(&amp;T, S1, S2)</span><br><span class="line">SUbString(&amp;Sub, S, pos, len)</span><br><span class="line">Index(S, T, pos)</span><br><span class="line">Replace(&amp;S, T, V)</span><br><span class="line">StrInsert(&amp;S, pos, T)</span><br><span class="line">StrDelete(&amp;S, pos, len)</span><br><span class="line">DestroyString(&amp;S)</span><br></pre></td></tr></table></figure></li><li><p>串的定长顺序表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> unsighed cahr SString[MAXSIZE + <span class="number">1</span>];<span class="comment">//0号位储存长度</span></span><br></pre></td></tr></table></figure><p>堆分配存储表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><p>串的块链存储表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ls</span>&#123;</span></span><br><span class="line">Chunk *head,  *tail;</span><br><span class="line"><span class="keyword">int</span> curlen;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></li><li><p><strong>串的模式匹配算法</strong>：</p><ul><li><p>简单但效率低下的普通算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> a, <span class="keyword">String</span> b, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pa = pos, pb = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(pa &lt;= a[<span class="number">0</span>] &amp;&amp; pb &lt;= b[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(a[pa] == b[pb])&#123;</span><br><span class="line">pa++;</span><br><span class="line">pb++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pa = pa - pb + <span class="number">1</span>;</span><br><span class="line">pb = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pb &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> (pa - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高效的KMP算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 计算next数组</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> a, <span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>, j = <span class="number">0</span>, next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || a[i] == a[j])&#123;</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 计算nextval数组, 比next数组更好</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> a, <span class="keyword">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>, j = <span class="number">0</span>, nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || a[i] == a[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != a[j]) nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 匹配函数主体</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IndexKMP</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= a[<span class="number">0</span>] &amp;&amp; j &lt;=b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || a[i] == b[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> (i - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="Unit-5-数组和广义表"><a href="#Unit-5-数组和广义表" class="headerlink" title="Unit 5 : 数组和广义表"></a>Unit 5 : 数组和广义表</h1><ol><li><p>数组的顺序存储：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *base;</span><br><span class="line">    <span class="keyword">int</span> dim;<span class="comment">//维数</span></span><br><span class="line">    <span class="keyword">int</span> *bounds;<span class="comment">//存储每一维的长度</span></span><br><span class="line">    <span class="keyword">int</span> *constants;<span class="comment">//某一维度的“1”所占空间</span></span><br><span class="line">&#125;Array;</span><br></pre></td></tr></table></figure></li><li><p>特殊矩阵与稀疏矩阵。</p></li><li><p>稀疏矩阵的表示：</p><ul><li>三元组顺序表：$\lfloor\log{n}\rfloor$</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tn</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple data[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;<span class="comment">//行数、列数、非零元个数</span></span><br><span class="line">&#125;Matrix;</span><br></pre></td></tr></table></figure><ul><li>行逻辑链接的顺序表：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tn</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple data[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> rpos[MAXRC+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;<span class="comment">//行数、列数、非零元个数</span></span><br><span class="line">&#125;Matrix;</span><br></pre></td></tr></table></figure><ul><li>十字链表：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qn</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">ELemType e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qn</span> *<span class="title">right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qn</span> *<span class="title">down</span>;</span></span><br><span class="line">&#125;QNode, *QPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cl</span>&#123;</span></span><br><span class="line">    QPtr *rhead, *chead;</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广义表非空时，称第一个元素a1为表头，其余元素组成的表称为表尾。</p></li><li><p>广义表的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gln</span>&#123;</span></span><br><span class="line">ElemTag tag;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">AtomType atom;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gln</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">&#125;ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Unit-6-树和二叉树"><a href="#Unit-6-树和二叉树" class="headerlink" title="Unit 6 : 树和二叉树"></a>Unit 6 : 树和二叉树</h1><ol><li><p>树的基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InitTree(&amp;T)</span><br><span class="line">DestroyTree(&amp;T)</span><br><span class="line">CreateTree(&amp;T, definition)</span><br><span class="line">ClearTree(&amp;T)</span><br><span class="line">TreeEmpty(T)</span><br><span class="line">TreeDepth(T)</span><br><span class="line">Root(T)</span><br><span class="line">Value(T, cur_e)</span><br><span class="line">Assign(T, cur_e, value)</span><br><span class="line">Parent(T, cur_e)</span><br><span class="line">LeftChild(T, cur_e)</span><br><span class="line">RIghtSibling(T, cur_e)</span><br><span class="line">InsertChild(&amp;T, &amp;p, i, c)</span><br><span class="line">DeleteChild(&amp;T, &amp;T, i)</span><br><span class="line">TraverseTree(T, visit())</span><br><span class="line">PreOrderTraverse(T, visit())</span><br><span class="line">InOrderTraverse(T, visit())</span><br><span class="line">PostOrderTraverse(T, visit())</span><br><span class="line">LevelOrderTraverse(T, visit())</span><br></pre></td></tr></table></figure></li><li><p>二叉树：每个结点至多只有两颗子树，且子树有左右之分.</p></li><li><p>二叉树的性质：</p><ol><li><p>在第i层上至多有$2^{i-1}$个结点。</p></li><li><p>深度为k的二叉树至多有$2^{k}-1$个结点。</p></li><li><p>对任意一颗二叉树，设其终端结点数位$n_0$, 度为2的结点数为$n_2$， 则有$n_0 = n_2 + 1$。</p></li></ol></li><li><p>满二叉树：深度为k且含有$2^k-1$个结点的二叉树。</p></li><li><p>完全二叉树：每个顶点的编号均与对应的满二叉树的编号一致。</p><ol><li>具有n个结点的完全二叉树的深度为$\lfloor\log_2{n}\rfloor+1$。</li><li>若有左孩子，则结点$2i$是结点$i$的左孩子；若有右孩子，则结点$2i+1$是结点$i$的右孩子。</li></ol></li><li><p>二叉树的存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序存储*/</span></span><br><span class="line"><span class="keyword">typedef</span> ELemType Tree[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链式存储*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tn</span>&#123;</span></span><br><span class="line">    ELemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tn</span> *<span class="title">lchild</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tn</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tn</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;TNode, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*递归建立二叉树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(Tree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a != <span class="number">-1</span>)&#123;</span><br><span class="line">        T = <span class="keyword">new</span> TNode;</span><br><span class="line">        T-&gt;data = a;</span><br><span class="line">        CreateTree(T-&gt;lchild);</span><br><span class="line">        CreateTree(T-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        T = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历*/</span></span><br><span class="line"><span class="comment">/*递归版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*非递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_f</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;Tree&gt; s;</span><br><span class="line">    Tree k = T;</span><br><span class="line">    <span class="keyword">while</span>(k || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;k-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.push(k);</span><br><span class="line">            k = k-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        k = s.top()-&gt;rchild;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line"><span class="comment">/*递归*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*非递归*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOderTraverse_f</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; s;</span><br><span class="line">    Tree k = T;</span><br><span class="line">    <span class="keyword">while</span>(k || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            s.push(k);</span><br><span class="line">            k = k-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s.top()-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        k = s.top()-&gt;rchild;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line"><span class="comment">/*递归*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*非递归*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse_f</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; s;</span><br><span class="line">    Tree k = T, m = <span class="literal">nullptr</span>, pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(k || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            s.push(k);</span><br><span class="line">            k = k-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        m = s.top()-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="literal">nullptr</span> || m == pre)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s.top()-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            pre = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*层序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Tree&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    q.push(T);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Tree k = q.front();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;k-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(k-&gt;lchild) q.push(k-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(k-&gt;rchild) q.push(k-&gt;rchild);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    CreateTree(T);</span><br><span class="line">    PreOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PreOrderTraverse_f(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    InOderTraverse_f(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PostOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PostOrderTraverse_f(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    LevelOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线索二叉树：在二叉树的基础上添加两个标志域LTag：值为0表示lchild指示结点的左孩子，值为1表示lchild指示结点的前驱，RTag：值为0表示rchild指示结点的左孩子，值为1表示rchild指示结点的后继。</p><p>其中指示前驱和后继的指针叫做线索。</p></li><li><p>树的孩子兄弟表示法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tn</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tn</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;TNode, *Tree;</span><br></pre></td></tr></table></figure></li><li><p>树和森林的转换，森林的遍历。</p></li><li><p>赫夫曼树与赫夫曼编码(重要，但并不难)。</p></li><li><p>树的计数：有着n个结点的不相似的二叉树有$\frac{1}{n+1}C_{2n}^{n}$棵。</p></li></ol><h1 id="Unit-7-图"><a href="#Unit-7-图" class="headerlink" title="Unit 7 : 图"></a>Unit 7 : 图</h1><ol><li><p>图的基本操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CreateGraph(&amp;G, Vex, Arc)</span><br><span class="line">DestroyGraph(&amp;G)</span><br><span class="line">LocateVex(G, u)</span><br><span class="line">GetVex(G, v)</span><br><span class="line">PutVex(&amp;G, v, value)</span><br><span class="line">FirstAdjVex(G, v)</span><br><span class="line">NextAdjVex(G, v)</span><br><span class="line">InsertVex(&amp;G, v)</span><br><span class="line">DeleteVex(&amp;G, v)</span><br><span class="line">InsertArc(&amp;G, v, w)</span><br><span class="line">DeleteArc(&amp;G, v, w)</span><br><span class="line">DFSTraverse(G, visit())</span><br><span class="line">BFSTraverse(G, visit())</span><br></pre></td></tr></table></figure></li><li><p>图的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">VRType adj;</span><br><span class="line">InfoType *info;</span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX1][MAX2];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg</span>&#123;</span></span><br><span class="line">    VexType vexs[MAX1];</span><br><span class="line">    AdjMatrix arcs;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">    <span class="keyword">int</span> kind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VexType data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;VNode, AdjList[MAX1];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ag</span>&#123;</span></span><br><span class="line">    AdjList vexs;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">    <span class="keyword">int</span> kind;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*还有逆邻接表、十字链表、邻接多重表等等*/</span></span><br></pre></td></tr></table></figure></li><li><p>图的遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*深度优先搜索*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        visit[v] = False;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v]) DFS(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(G, v)</span></span>&#123;</span><br><span class="line">    visit[v] = True;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.vexs[v]-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span>(w = FirstAdjVex(G, v); w &gt; <span class="number">0</span>; w = NextAdjVex(G, v, w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[w]) DFS(G, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*广度优先搜索*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        visit[v] = False;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">            q.push(v);</span><br><span class="line">            visit[v] = True;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;G.vexs[v]-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                k = q.front();</span><br><span class="line">                <span class="keyword">for</span>(w = FirstAdjVex(G, k); w &gt; <span class="number">0</span>; w = NextAdjVex(G, k, w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[w])&#123;</span><br><span class="line">                        visit[w] = True;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;G.vexs[v]-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                        q.push(w);</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>最小生成树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Prim算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(MGraph G, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; G.vexnum; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j != k)&#123;</span><br><span class="line">closedis[j] = dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    closedis[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="built_in">min</span> = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(closedis[j] != <span class="number">0</span> &amp;&amp; closedis[j] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出相关信息， cout&lt;&lt;......</span></span><br><span class="line">        closedis[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; vexnum; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[k][j] &lt; closedis[j])&#123;</span><br><span class="line">                closedis[j] = dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Prim算法的复杂度与网中的边数无关，因此适合求便稠密的网的最小生成树*/</span></span><br></pre></td></tr></table></figure></li><li><p>关节点与重连通分量:<br>$$<br>low(v) = min\left{visited[v],low[w], visited[k]\right}<br>$$<br>其中w是顶点在深度优先生成树中的孩子结点，k是顶点v在深度优先生成树上回边联结的祖先顶点。</p><p>倘若有某个顶点v，存在某个孩子结点w且$low[w]&gt;visited[v]$, 则v为关节点。</p></li><li><p>拓扑排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopoSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">GetInDegree(G,indegree)<span class="comment">//对图中顶点求入度，并把数据存储到indegree数组中</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!indegree[i])&#123;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line"><span class="comment">//输出s.top()元素的相关信息,cout&lt;&lt;...</span></span><br><span class="line">        k = s.top();</span><br><span class="line">        <span class="keyword">for</span>(w = FirstAdjVex(G, k); w &gt; <span class="number">0</span>; w = NexAdjVex(G, k, w))&#123;</span><br><span class="line">            indegree[w]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[w] == <span class="number">0</span>) s.push(w);</span><br><span class="line">        &#125;</span><br><span class="line">        s.pop();</span><br><span class="line">        count++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="comment">//输出或返回相关信息，表明该图非连通</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键路径：</p><p>利用栈进行<strong>逆拓扑排序</strong>，求得时间的最迟发生时间，与最早发生时间比较后，即可判断是否为关键活动。</p></li><li><p>最短路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单源最短路径*/</span></span><br><span class="line"><span class="comment">/*Dijkstra算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">visit[i] = False;<span class="comment">//visit数组将用来储存那些已经确定了最短路径的顶点</span></span><br><span class="line">dis[i] = G.arcs[v][i];<span class="comment">//dis数组用来存储最短路径的大小，初始值设为点到源(起始点)的距离</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)&#123;</span><br><span class="line">Path[i][j] = False;</span><br><span class="line"><span class="comment">/*Path数组用来存储最短路径经过的具体点，Path[v][w]的真假表示从起始点到v的最短路径上是否经过了w点*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dis[i] &lt; INFINITY)&#123;<span class="comment">/*能够确保一定能到达i点,则i点和v点都必在最短路径中*/</span></span><br><span class="line">Path[i][v] = True;</span><br><span class="line">Path[i][i] = True;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[v] = True;</span><br><span class="line">dis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.vexnum; i++)&#123;<span class="comment">//循环“顶点数-1”次</span></span><br><span class="line"><span class="built_in">min</span> = INFINITY;</span><br><span class="line"><span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[w] &amp;&amp; dis[w] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">k = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[k] = True;</span><br><span class="line"><span class="comment">/*更新最短路径*/</span></span><br><span class="line"><span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[w] &amp;&amp; (dis[k] + G.arcs[k][w] &lt; dis[w]))&#123;</span><br><span class="line">                dis[w] = dis[k] + G.arcs[k][w];</span><br><span class="line">                Path[w] = Path[k];<span class="comment">//继承从源(起始点)到k的这段路径</span></span><br><span class="line">                Path[w][w] = True;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多源最短路径*/</span></span><br><span class="line"><span class="comment">/*Floyd算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; i++)&#123;</span><br><span class="line">            dis[i][j] = G.arcs[i][j];</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)&#123;</span><br><span class="line">                Path[i][j][u] = False;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j] &lt; INFINITY)&#123;</span><br><span class="line">                P[i][j][i] = True;</span><br><span class="line">                P[i][j][j] = True;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*更新最短路径矩阵*/</span></span><br><span class="line">    <span class="keyword">for</span>(mid = <span class="number">0</span>; mid &lt; G.vexnum; mid++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][mid] + dis[mid][j] &lt; dis[i][j])&#123;</span><br><span class="line">                    dis[i][j] = dis[i][mid] + dis[mid][j];</span><br><span class="line">                    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">                        P[i][j][w] = P[i][mid][w] || P[mid][j][w];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Unit-8-查找"><a href="#Unit-8-查找" class="headerlink" title="Unit 8 : 查找"></a>Unit 8 : 查找</h1><ol><li><p>折半查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Binary_Search(List L, KeyType key)&#123;</span><br><span class="line">low = <span class="number">1</span>, high = length;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(key == L[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span>(key &gt; L[mid].key) low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态最优查找树的建立、索引顺序表的查找(需要理解其中的思想)。</p></li><li><p>二叉排序树：</p><ul><li><p>二叉排序树的性质：</p><ol><li>若左子树不为空，则左子树上所有顶点的值均小于它的根结点的值。</li><li>若右子树不为空，则右子树上所有顶点的值均大于它的根结点的值。</li><li>左右子树均为二叉排序树</li></ol></li><li><p>二叉排序树的查找、插入和删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查找*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(BiTree T, KeyType key, BiTree fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = fa;<span class="comment">///fa为T结点的父节点</span></span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data.key)&#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> True;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data.key)&#123;</span><br><span class="line">        <span class="keyword">return</span> Search(T-&gt;lchild, key, T);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Search(T-&gt;rchild, key, T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(BiTree &amp;T, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Search(T, e.key, <span class="literal">nullptr</span>))&#123;</span><br><span class="line">        pnode = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        pnode-&gt;data = e;</span><br><span class="line">        pnode-&gt;lchild = pnode-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) T = pnode;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e.key &lt; p-&gt;data.key) p-&gt;lchild = pnode;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rchild = pnode;</span><br><span class="line">        <span class="keyword">return</span> True;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> False;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)&#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q != p) q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>平衡二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*平衡二叉树的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> bf;<span class="comment">//左子树深度-右子树深度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"><span class="comment">/*二叉平衡树的旋转分为四种类型，需要理解其中的原理*/</span></span><br></pre></td></tr></table></figure></li><li><p>B-树</p><ul><li><p>一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：</p><ol><li>树中每个结点至多有m棵子树。</li><li>若根结点不是叶子结点，则至少有两棵子树。</li><li>除根之外的所有非终端结点至少有$\lceil{m/2}\rceil$棵子树。</li><li>叶子结点都出现在同一层次上，且不带信息。</li></ol></li><li><p>B-树的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 3 <span class="comment">//B-树的阶数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> keynum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">    KeyType key[m + <span class="number">1</span>];<span class="comment">//0号单元不用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">ptr</span>[<span class="title">m</span> + 1];</span></span><br><span class="line">    Record *recptr[m + <span class="number">1</span>];<span class="comment">//0号单元不用</span></span><br><span class="line">&#125;BTNode, *BTree;</span><br></pre></td></tr></table></figure></li><li><p>关键字的数目比子树的数目要少1。</p></li><li><p>B-树的插入和删除(掌握思想，尤其是结点的分裂和合并)</p></li></ul></li><li><p>B+树：叶子结点中包含了全部关键字的信息，所有的非终端结点可以看成是索引。</p></li><li><p>键树：又称数字查找树。</p></li><li><p>哈希表：</p><ul><li><p>哈希函数的构造：</p><ol><li><p>直接定址法：取关键字或关键字的某个线性函数值为哈希地址。</p></li><li><p>数字分析法。</p></li><li><p>平方取中法。</p></li><li><p>折叠法。</p></li><li><p>除留余数法：取关键字被某个不大于表长m的数p除后所得余数为哈希地址。</p><p>一般情况下，可选p为质数或不包含小于20的质因数的合数。</p></li><li><p>随机数法。</p></li></ol></li><li><p>哈希冲突的处理：</p><ol><li>开放定址法：<ul><li>线性探测再散列，$ 1，2，3，\cdots, m-1$</li><li>二次探测再散列，$1^2, -1^2, 2^2, -2^2, 3^2, \cdots,\pm{k^2}$</li><li>伪随机探测再散列</li></ul></li><li>再哈希法</li><li>链地址法</li><li>建立一个公共溢出区</li></ol></li><li><p>哈希表的装填因子定义为<br>$$<br>\alpha = \frac{表中填入的记录数}{哈希表的长度}<br>$$</p><table><thead><tr><th align="left">方法</th><th align="center">哈希表查找成功时的平均查找长度</th><th align="center">哈希表查找失败时的平均查找长度</th></tr></thead><tbody><tr><td align="left">线性探测</td><td align="center">$\frac{1}{2}(1+\frac{1}{1-\alpha})$</td><td align="center">$\frac{1}{2}(1-\frac{1}{(1-\alpha)^2})$</td></tr><tr><td align="left">随机、二次探测、再哈希</td><td align="center">$-\frac{1}{\alpha}\ln(1-\alpha)$</td><td align="center">$\frac{1}{1-\alpha}$</td></tr><tr><td align="left">链地址法</td><td align="center">$1+\frac{\alpha}{2}$</td><td align="center">$\alpha+e^\alpha$</td></tr></tbody></table></li></ul></li></ol><h1 id="Unit-9-排序"><a href="#Unit-9-排序" class="headerlink" title="Unit 9 : 排序"></a>Unit 9 : 排序</h1><ol><li><p>稳定排序与不稳定排序：稳定是指相等元素在排序前后的相对位置不发生改变。</p></li><li><p>直接插入排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(List &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i<span class="number">-1</span>])&#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; L[j] &gt; L[<span class="number">0</span>]; j--)&#123;</span><br><span class="line">                L[j+<span class="number">1</span>] = L[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L[j] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*也有对直接插入排序的优化算法，如折半插入排序，思想类似于先二分查找到插入的最佳位置，然后移动位置*/</span></span><br></pre></td></tr></table></figure></li><li><p>希尔排序：</p><p>希尔排序又称”缩小增量排序”。</p><p>大致思想：按增量将原序列分成多个小序列，各自进行插入排序。因为有多个增量，所以上一步要进行多次。</p></li><li><p>快速排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FastSort</span><span class="params">(List &amp;L, start, <span class="built_in">end</span>)</span></span>&#123;<span class="comment">//对[start, end]这个区域进行快速排序</span></span><br><span class="line"><span class="comment">//快排的核心思想是把比中心值大的元素统统放在中心值的右边，小的放在中心值的左边</span></span><br><span class="line">key = List[start];<span class="comment">//选定快排的中心值</span></span><br><span class="line">s = start;</span><br><span class="line">e = <span class="built_in">end</span>;<span class="comment">//设置两个伪指针,采用两头向中间靠拢的策略</span></span><br><span class="line"><span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">        <span class="comment">//先移动右指针，找到合适的值填到中心值的位置</span></span><br><span class="line"><span class="keyword">while</span>(List[e] &gt; key &amp;&amp; e &gt; s) e--;<span class="comment">//值比中心值大，说明位置合适，需继续往左走，1.直到找到了比中心值小的值，2.或者说发现没有这种值，都需要退出循环</span></span><br><span class="line">        List[s] = List[e];<span class="comment">//把不合适的值移到左边来</span></span><br><span class="line">        <span class="comment">//现在发现我们只改变了，List[s]的值，List[e]位置的值还是原来那个不合适的值。此时我们就需要移动左指针，找到一个合适的值来填到List[e]的位置</span></span><br><span class="line">        <span class="keyword">while</span>(List[s] &lt; key &amp;&amp; e &gt; s) s++;<span class="comment">//值比中心值小，说明位置合适，需继续往右走，1.直到找到了比中心值大的值，2.或者说发现没有这种值，都需要退出循环</span></span><br><span class="line">        List[e] = List[s];<span class="comment">//现在List[s]的值就合理了</span></span><br><span class="line">        <span class="comment">/*如此反复循环,直到s == e退出循环*/</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*退出循环后我们发现，此时恰好给中心值腾出了一个位置*/</span></span><br><span class="line">    List[s] = key;<span class="comment">//将中心值填入即可</span></span><br><span class="line">    <span class="comment">/*对中心值两边同样进行快排*/</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; s - <span class="number">1</span>) FastSort(L, start, s - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(s + <span class="number">1</span> &lt; <span class="built_in">end</span>) FastSort(L, s + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单选择排序(如其名，简单)。</p></li><li><p>堆排序：</p><ul><li><p>小顶堆需满足以下条件：<br>$$<br>\begin{cases}<br>k_i\leq{k_{2i}}\<br>k_i\leq{k_{2i+1}}<br>\end{cases}<br>$$<br>大顶堆需满足以下条件：<br>$$<br>\begin{cases}<br>k_i\geq{k_{2i}}\<br>k_i\geq{k_{2i+1}}<br>\end{cases}<br>$$</p></li><li><p>堆排序的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*大顶堆*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(List &amp;L, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    key = L[start];</span><br><span class="line">    <span class="keyword">for</span>(m = start * <span class="number">2</span>; m &lt;= <span class="built_in">end</span>; m *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[m+<span class="number">1</span>] &gt; L[m]) m = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt;= L[m]) <span class="keyword">break</span>;</span><br><span class="line">        L[start] = L[m];<span class="comment">//交换位置</span></span><br><span class="line">        start = m;</span><br><span class="line">    &#125;</span><br><span class="line">    L[start] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(List &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*建立大顶堆*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        HeapAdjust(L, i, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt; <span class="number">1</span>; i--)&#123;</span><br><span class="line">        temp = L[<span class="number">1</span>];</span><br><span class="line">        L[<span class="number">1</span>] = L[i];</span><br><span class="line">        L[i] = temp;</span><br><span class="line">        HeapAdjust(L, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="7"><li><p>归并排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(List &amp;T, List T2, <span class="keyword">int</span> start, <span class="keyword">int</span> m, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = start;</span><br><span class="line">    <span class="keyword">int</span> b = m + <span class="number">1</span>;<span class="comment">//设置两个伪指针</span></span><br><span class="line">    <span class="keyword">int</span> c= <span class="number">0</span>;<span class="comment">//设置T的伪指针</span></span><br><span class="line">    <span class="keyword">while</span>(a &lt;= m &amp;&amp; b &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T2[a] &lt; T2[b])&#123;</span><br><span class="line">            T[++c] = T[a];</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            T[++c] = T[b];</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a &lt;= m)&#123;</span><br><span class="line">        T[++c] = T[a];</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        T[++c] = T[b];</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(List L, List &amp;T,<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        T[start] = L[start];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(L, T2, start, m);</span><br><span class="line">        MergeSort(L, T2, m+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        Merge(T, T2,start, m ,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>基数排序</p><p>基数排序就是distribute和collect方法的多次使用。</p><p>依次根据各个关键字将原序列分配成一组列表，再把列表收集起来串成一串，如此反复，直到完成排序。</p></li><li><p>各种排序方法的比较：</p><table><thead><tr><th align="center">排序方法</th><th align="center">平均时间</th><th align="center">最佳情况</th><th align="center">最坏情况</th><th align="center">辅助空间</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">简单选择排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">直接插入排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">折半插入排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n^{2})$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">$O(n^{1.3})$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n\cdot\log{n})$</td><td align="center">$O(n^2)$</td><td align="center">$O(\log{n})$</td><td align="center">不稳定</td></tr><tr><td align="center">基数排序</td><td align="center">$O(d\cdot(n+r))$</td><td align="center">$O(d\cdot(n+r))$</td><td align="center">$O(d\cdot(n+r))$</td><td align="center">$O(d\cdot(n+r))$</td><td align="center">稳定</td></tr></tbody></table></li><li><p>地址排序(理解思想)</p></li><li><p>外部排序的读写次数：$物理块的数目\times(2\times归并趟数+2)$</p></li><li><p>败者树(理解思想)</p></li><li><p>置换选择排序(败者树的应用，理解思想)</p></li><li><p>最佳归并树：若$(m-1)MOD(k-1)=0$则不需要加虚段，否则需要加$k-1-(m-1)MOD(k-1)$个虚段。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docx库操作入门</title>
      <link href="/2020/06/20/docx%E5%BA%93%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/20/docx%E5%BA%93%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>docx库的下载指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-docx</span><br></pre></td></tr></table></figure><h2 id="1、文档"><a href="#1、文档" class="headerlink" title="1、文档"></a>1、文档</h2><p><strong>创建文档</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line">document = Document()</span><br></pre></td></tr></table></figure><p><strong>保存文档</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.save(<span class="string">'test.docx'</span>)</span><br></pre></td></tr></table></figure><p><strong>打开现有文档</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document = Document(<span class="string">'filename.docx'</span>)  <span class="comment"># 打开</span></span><br><span class="line">document.save(<span class="string">'new-filename.docx'</span>)  <span class="comment">#保存文档</span></span><br></pre></td></tr></table></figure><p>如果使用相同的文件名来打开和保存文件，将默认覆盖原文件</p><p><strong>打开file-like文档</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'a.docx'</span>, <span class="string">'rb'</span>)</span><br><span class="line">document = DOcument(f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.docx'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">source_stream = StringIO(f.read())</span><br><span class="line">document = Document(source_stream)</span><br><span class="line">source_stream.close()</span><br><span class="line"></span><br><span class="line">target_stream = StringIO()</span><br><span class="line">document.save(target_stream)</span><br></pre></td></tr></table></figure><h2 id="2、段落"><a href="#2、段落" class="headerlink" title="2、段落"></a>2、段落</h2><p><strong>添加段落</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph = document.add_paragraph(<span class="string">"This is the first paragraph"</span>)</span><br></pre></td></tr></table></figure><p>作用：在文档末尾添加一个新的段落，并返回该段落的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prior_paragraph = paragraph.insert_paragraph_before(<span class="string">"such a good boy"</span>)</span><br></pre></td></tr></table></figure><p>作用：以某个段落为基准，在这个段落前添加一个新的段落。</p><p><strong>添加段落风格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph.style = <span class="string">"List Bullet"</span></span><br></pre></td></tr></table></figure><p>这种风格使得段落看起来像子弹头。</p><p><strong>在段落中添加内容</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run = paragraph.add_run(<span class="string">"it is wonderful"</span>)</span><br><span class="line">run = paragraph.add_run(<span class="string">"it is wonderful"</span>, <span class="string">"Emphasis"</span>)  <span class="comment"># 创建时指定风格</span></span><br></pre></td></tr></table></figure><p>这还将返回一个对字符串”it is wonderful”的引用，我们可以对这个字符串进行格式的设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run.bold = <span class="literal">True</span>  <span class="comment"># 设置为粗体</span></span><br><span class="line">run.italic = <span class="literal">True</span>  <span class="comment"># 设置为斜体</span></span><br><span class="line">run.style = <span class="string">"Emphasis"</span> <span class="comment"># 创建后设置风格</span></span><br></pre></td></tr></table></figure><p><strong>设置段落格式</strong></p><p>段落的对齐方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx.enum.text <span class="keyword">import</span> WD_ALIGN_PARAGRAPH</span><br><span class="line"></span><br><span class="line">paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER  <span class="comment"># 设置为居中对齐</span></span><br></pre></td></tr></table></figure><p>段落的缩进</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paragraph.paragraph_format.left_indent = Inches(<span class="number">0.5</span>)  <span class="comment"># 向左缩进</span></span><br><span class="line">paragraph.paragraph_format.right_indent = Inches(<span class="number">0.5</span>)  <span class="comment"># 向右缩进</span></span><br><span class="line">paragraph.paragraph_format.first_line_indent = Inches(<span class="number">0.5</span>)  <span class="comment">#第一行缩进</span></span><br></pre></td></tr></table></figure><p><strong>段落间隔</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Pt</span><br><span class="line"></span><br><span class="line">paragraph.paragraph_format.space_before = Pt(<span class="number">18</span>)</span><br><span class="line">paragraph.paragraph_format.space_after = Pt(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><strong>行间距</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph.paragraph_format.line_spacing &#x3D; Pt(18)</span><br></pre></td></tr></table></figure><p>分页属性：</p><p>keep_together：使整个段落出现在同一页上，如果该段落可能被分割成两页，则在该段之前加入分页符。</p><p>keep_with_next：保持与下一段保持一个段落在相同的页面。</p><p>page_break_before：使用分页符将段落放置在新页的顶部。</p><p>widow_control：避免将该段的第一行或最后一行放在与该段其余部分分开的页面上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph.paragraph_format.keep_together = <span class="literal">True</span></span><br><span class="line">paragraph.paragraph_format.keep_with_next = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="3、标题"><a href="#3、标题" class="headerlink" title="3、标题"></a>3、标题</h2><p><strong>添加标题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.add_heading(<span class="string">'My first doc created by python'</span>)</span><br></pre></td></tr></table></figure><p>作用：添加一个顶级标题。</p><p>标题共有9级，可通过level属性来指定级数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.add_heading(<span class="string">'My first doc created by python'</span>, level=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>会创建一个3级标题。</p><p>若指定级别为0，则将创建一个段落</p><h2 id="4、分页符"><a href="#4、分页符" class="headerlink" title="4、分页符"></a>4、分页符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.add_page_break()</span><br></pre></td></tr></table></figure><p>作用：无论所在页面是否已满，都将转到一个新的页面上</p><h2 id="5、表格"><a href="#5、表格" class="headerlink" title="5、表格"></a>5、表格</h2><p><strong>添加表格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table = document.add_table(rows=<span class="number">2</span>, cols=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>作用：创建一个2行，2列的表格(可视作一个二维数组)</p><p><strong>获取引用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell = table.cell(<span class="number">0</span>,<span class="number">1</span>)  <span class="comment"># 获取第一行第二列的元素的引用</span></span><br><span class="line">row = table.rows[<span class="number">1</span>]  <span class="comment"># 获取第二行的引用</span></span><br><span class="line">cell = row.cells[<span class="number">1</span>] <span class="comment">#  获取第二行(即上一行代码所获得的行)的第二个元素</span></span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cell.text = <span class="string">'hello, good morning'</span>  <span class="comment"># 修改单元格的文本</span></span><br><span class="line">row_count = len(table.rows)  <span class="comment"># 统计表格行数</span></span><br><span class="line">row = table.add_row()  <span class="comment"># 添加新的一行</span></span><br><span class="line">table.style = <span class="string">'LightShading-Acccent1'</span>  <span class="comment"># 表格样式</span></span><br></pre></td></tr></table></figure><h2 id="6、图片"><a href="#6、图片" class="headerlink" title="6、图片"></a>6、图片</h2><p><strong>添加图片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.add_picture(&#39;snow.jpg&#39;)</span><br></pre></td></tr></table></figure><p>添加了一张文件名为”snow.jpg”的图片</p><p><strong>控制图片大小</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form docx.shared <span class="keyword">import</span> Inches</span><br><span class="line"></span><br><span class="line">document.add_picture(<span class="string">'snow.jpg'</span>, width=Inches(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="7、字体设置"><a href="#7、字体设置" class="headerlink" title="7、字体设置"></a>7、字体设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Pt</span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> RGBColor</span><br><span class="line"><span class="keyword">from</span> docx.enum.dml <span class="keyword">import</span> MSO_THEME_COLOR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run = document.add_paragraph().add_run()</span><br><span class="line">font = run.font</span><br><span class="line">font.name = <span class="string">'Calibri'</span>  <span class="comment">#字体种类</span></span><br><span class="line">font.size = Pt(<span class="number">12</span>)   <span class="comment">#字体大小</span></span><br><span class="line">font.bold = <span class="literal">True</span>  <span class="comment"># 粗体</span></span><br><span class="line">font.italic = <span class="literal">False</span>  <span class="comment"># 斜体</span></span><br><span class="line">font.underline = <span class="literal">True</span>  <span class="comment"># 下划线</span></span><br><span class="line">font.color.rgb = RGBColor(<span class="number">0x42</span>, <span class="number">0x24</span>, <span class="number">0xE9</span>)  <span class="comment"># 字体颜色</span></span><br><span class="line">font.clor.theme_color = MSO_THEME_COLOR.ACCENT_1  <span class="comment"># 设置配色</span></span><br><span class="line">font.color.rgb = <span class="literal">None</span>  <span class="comment"># 默认颜色</span></span><br></pre></td></tr></table></figure><h2 id="8、section属性"><a href="#8、section属性" class="headerlink" title="8、section属性"></a>8、section属性</h2><p><strong>section的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sections = document.sections</span><br><span class="line">section = sections[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>section的属性</strong></p><ul><li><p>start_type：这个部分之前的断开类型</p></li><li><p>orientation：页面方向</p></li><li><p>page_width：页面宽度</p></li><li><p>page_height：页面高度</p></li><li><p>left_margin：左边距</p></li><li><p>right_margin：右边距</p></li><li><p>top_margin：上边距</p></li><li><p>bottom_margin：下边距</p></li><li><p>gutter</p></li><li><p>header_distance</p></li><li><p>footer_distance</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section.start_type = WD_SECTION.ODD_PAGE</span><br><span class="line">section.orientation = WD_ORIENT.LANDSCAPE</span><br><span class="line">section.page_width = new_width</span><br><span class="line">section.page_height = new_height</span><br><span class="line">section.left_margin = Inches(<span class="number">1.5</span>)</span><br><span class="line">section.right_margin = Inches(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="9、页眉和页脚"><a href="#9、页眉和页脚" class="headerlink" title="9、页眉和页脚"></a>9、页眉和页脚</h2><p>获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">section = document.sections[<span class="number">0</span>]</span><br><span class="line">header = section.header</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">paragraph &#x3D; header.paragraphs[0]</span><br><span class="line">paragraph.text &#x3D; &quot;Title of my document&quot;  # 在页眉添加内容</span><br><span class="line">paragraph.text &#x3D; &quot;Left Text\tCenter Text\tRight Text&quot;  #制表符用于分隔左、中和右对齐的标题内容</span><br><span class="line">paragraph.style &#x3D; document.styles[&#39;header&#39;]</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.is_linked_to_previous &#x3D; True</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> docx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown进阶篇——简单的公式编辑</title>
      <link href="/2020/06/20/markdown%E8%BF%9B%E9%98%B6%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/"/>
      <url>/2020/06/20/markdown%E8%BF%9B%E9%98%B6%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown进阶篇——简单的公式编辑"><a href="#markdown进阶篇——简单的公式编辑" class="headerlink" title="markdown进阶篇——简单的公式编辑"></a>markdown进阶篇——简单的公式编辑</h1><ol><li><p>在Typora中添加公式：</p><ul><li><p>添加一个简单的数学式：</p><p>进入Typora偏好设置界面，进入markdown设置，将markdown拓展语法全部勾选</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200620213143506.png" alt="image-20200620213143506"></p><p>然后在Typora的编辑界面使用’$’符号包裹住你的LaTeX公式即可，用法类似添加简单的代码`。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是$a^2$</span><br></pre></td></tr></table></figure><p>效果：</p><p>这是$a^2$</p></li><li><p>添加一个较复杂的数学公式块，使用’$$’包裹注你的LaTeX公式即可，用法类似添加代码块```。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a^2_1</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：<br>$$<br>a^2_1<br>$$</p></li></ul></li><li><p>常用符号表：</p><table><thead><tr><th>符号</th><th align="left">示例</th><th>效果</th></tr></thead><tbody><tr><td>上标</td><td align="left"><code>$a^2$</code></td><td>$a^2$</td></tr><tr><td>下标</td><td align="left"><code>$a_2$</code></td><td>$a_2$</td></tr><tr><td>分式</td><td align="left"><code>$1/2$</code></td><td>$1/2$</td></tr><tr><td>分式</td><td align="left"><code>$\frac{1}{2}$</code></td><td>$\frac{1}{2}$</td></tr><tr><td>省略号</td><td align="left"><code>$\cdots$</code></td><td>$\cdots$</td></tr><tr><td>根号</td><td align="left"><code>$\sqrt[n]{m}$</code></td><td>$\sqrt[n]{m}$</td></tr><tr><td>矢量</td><td align="left"><code>$\vec{a}$</code></td><td>$\vec{a}$</td></tr><tr><td>积分</td><td align="left"><code>$\int{x}dx$</code></td><td>$\int{x}dx$</td></tr><tr><td>积分</td><td align="left"><code>$\int^{b}_{a}{x}dx$</code></td><td>$\int^{b}_{a}{x}dx$</td></tr><tr><td>极限</td><td align="left"><code>$\lim_{n \to \infty}{\frac{1}{n}}$</code></td><td>$\lim_{n \to \infty}{\frac{1}{n}}$</td></tr><tr><td>极限</td><td align="left"><code>$\lim\limits_{n \to \infty}{\frac{1}{n}}$</code></td><td>$\lim\limits_{n \to \infty}{\frac{1}{n}}$</td></tr><tr><td>极限</td><td align="left"><code>$\lim\limits_{n \to +\infty}{\frac{1}{n}}$</code></td><td>$\lim\limits_{n \to +\infty}{\frac{1}{n}}$</td></tr><tr><td>累加</td><td align="left"><code>$\sum_{n=1}^{+\infty}{a_n}$</code></td><td>$\sum_{n=1}^{+\infty}{a_n}$</td></tr><tr><td>累加</td><td align="left"><code>$\sum\limits_{n=1}^{+\infty}{a_n}$</code></td><td>$\sum\limits_{n=1}^{+\infty}{a_n}$</td></tr><tr><td>累乘</td><td align="left"><code>$\prod_{n=1}^{100}{a_n}$</code></td><td>$\prod_{n=1}^{100}{a_n}$</td></tr><tr><td>累乘</td><td align="left"><code>$\sum\limits_{n=1}^{100}{a_n}$</code></td><td>$\sum\limits_{n=1}^{100}{a_n}$</td></tr></tbody></table></li><li><p>希腊字母表：</p><table><thead><tr><th>markdown</th><th>字母</th></tr></thead><tbody><tr><td><code>$\alpha$</code></td><td>$\alpha$</td></tr><tr><td><code>$\beta$</code></td><td>$\beta$</td></tr><tr><td><code>$\gamma$</code></td><td>$\gamma$</td></tr><tr><td><code>$\delta$</code></td><td>$\delta$</td></tr><tr><td><code>$\epsilon$</code></td><td>$\epsilon$</td></tr><tr><td><code>$\varepsilon$</code></td><td>$\varepsilon$</td></tr><tr><td><code>$\zeta$</code></td><td>$\zeta$</td></tr><tr><td><code>$\eta$</code></td><td>$\eta$</td></tr><tr><td><code>$\theta$</code></td><td>$\theta$</td></tr><tr><td><code>$\iota$</code></td><td>$\iota$</td></tr><tr><td><code>$\kappa$</code></td><td>$\kappa$</td></tr><tr><td><code>$\lambda$</code></td><td>$\lambda$</td></tr><tr><td><code>$\mu$</code></td><td>$\mu$</td></tr><tr><td><code>$\nu$</code></td><td>$\nu$</td></tr><tr><td><code>$\xi$</code></td><td>$\xi$</td></tr><tr><td><code>$\omicron$</code></td><td>$\omicron$</td></tr><tr><td><code>$\pi$</code></td><td>$\pi$</td></tr><tr><td><code>$\rho$</code></td><td>$\rho$</td></tr><tr><td><code>$\sigma$</code></td><td>$\sigma$</td></tr><tr><td><code>$\tau$</code></td><td>$\tau$</td></tr><tr><td><code>$\upsilon$</code></td><td>$\upsilon$</td></tr><tr><td><code>$\phi$</code></td><td>$\phi$</td></tr><tr><td><code>$\varphi$</code></td><td>$\varphi$</td></tr><tr><td><code>$\chi$</code></td><td>$\chi$</td></tr><tr><td><code>$\psi$</code></td><td>$\psi$</td></tr><tr><td><code>$\omega$</code></td><td>$\omega$</td></tr></tbody></table></li><li><p>常用函数表：</p><table><thead><tr><th>函数</th><th>markdown</th><th>效果</th></tr></thead><tbody><tr><td>正弦函数</td><td><code>$\sin\alpha$</code></td><td>$\sin\alpha$</td></tr><tr><td>余弦函数</td><td><code>$\cos\beta$</code></td><td>$\cos\beta$</td></tr><tr><td>对数函数</td><td><code>$\ln(a+b)$</code></td><td>$\ln(a+b)$</td></tr><tr><td>对数函数</td><td><code>$\log_n(a+b)$</code></td><td>$\log_n(a+b)$</td></tr><tr><td>对数函数</td><td><code>$\lg10$</code></td><td>$\lg10$</td></tr><tr><td>取整函数</td><td><code>$\lfloor{a+b}\rfloor$</code></td><td>$\lfloor{a+b}\rfloor$</td></tr><tr><td>取顶函数</td><td><code>$\lceil{a+b}\rceil$</code></td><td>$\lceil{a+b}\rceil$</td></tr></tbody></table></li><li><p>关系运算符：</p><table><thead><tr><th>markdown</th><th>效果</th></tr></thead><tbody><tr><td><code>$\pm$</code></td><td>$\pm$</td></tr><tr><td><code>$\times$</code></td><td>$\times$</td></tr><tr><td><code>$\cdot$</code></td><td>$\cdot$</td></tr><tr><td><code>$\div$</code></td><td>$\div$</td></tr><tr><td><code>$\neq$</code></td><td>$\neq$</td></tr><tr><td><code>$\equiv$</code></td><td>$\equiv$</td></tr><tr><td><code>$\leq$</code></td><td>$\leq$</td></tr><tr><td><code>$\geq$</code></td><td>$\geq$</td></tr></tbody></table></li><li><p>特殊字符：</p><table><thead><tr><th>markdown</th><th>效果</th></tr></thead><tbody><tr><td><code>$\forall$</code></td><td>$\forall$</td></tr><tr><td><code>$\infty$</code></td><td>$\infty$</td></tr><tr><td><code>$\emptyset$</code></td><td>$\emptyset$</td></tr><tr><td><code>$\exists$</code></td><td>$\exists$</td></tr><tr><td><code>$\nabla$</code></td><td>$\nabla$</td></tr><tr><td><code>$\bot$</code></td><td>$\bot$</td></tr><tr><td><code>$\angle$</code></td><td>$\angle$</td></tr><tr><td><code>$\because$</code></td><td>$\because$</td></tr><tr><td><code>$\therefore$</code></td><td>$\therefore$</td></tr></tbody></table></li></ol><ol start="7"><li><p>方程组的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">a + b &#x3D; c\\</span><br><span class="line">a &#x3D; 2b</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：<br>$$<br>\begin{cases}<br>a + b = c\<br>a = 2b<br>\end{cases}<br>$$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python正则表达式</title>
      <link href="/2020/06/09/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/06/09/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="导入正则表达式库"><a href="#导入正则表达式库" class="headerlink" title="导入正则表达式库"></a>导入正则表达式库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="match函数"><a href="#match函数" class="headerlink" title="match函数"></a>match函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对字符串的开头进行匹配，匹配失败将返回None</p><p>参数:</p><ul><li>pattern：正则表达式字符串</li><li>string：目标字符串</li><li>flags：<pre><code>* re.I     使匹配对大小写不敏感        * re.M   多行匹配        * re.S     拓展&quot;.&quot;的匹配，使其也能匹配换行符        * re.U     根据Unicode解析字符        * re.X              * re.L      本地化识别匹配</code></pre></li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(re.match(<span class="string">r'sn'</span>, <span class="string">'snow'</span>))</span><br><span class="line">print(re.match(<span class="string">r'sn'</span>, <span class="string">'snow'</span>).span())</span><br><span class="line">print(re.match(<span class="string">r'ow'</span>, <span class="string">'snow'</span>))  <span class="comment"># 倘若无匹配，则不能使用span方法，否则会报错</span></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610103805429.png" alt="image-20200610103805429"></p><p>返回对象的group方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'great grass hello grey'</span></span><br><span class="line">match_obj = re.match(<span class="string">r'(.*) grass (.*)'</span>, string)</span><br><span class="line"><span class="keyword">if</span> match_obj:</span><br><span class="line">    print(match_obj.group())</span><br><span class="line">    print(match_obj.group(<span class="number">1</span>))</span><br><span class="line">    print(match_obj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No match"</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610105558990.png" alt="image-20200610105558990"></p><p>flags使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'great Grass hello grey'</span></span><br><span class="line">match_obj1 = re.match(<span class="string">r'(.*) grass (.*)'</span>, string)</span><br><span class="line">match_obj2 = re.match(<span class="string">r'(.*) grass (.*)'</span>, string, re.I)</span><br><span class="line"><span class="keyword">if</span> match_obj1:</span><br><span class="line">    print(<span class="string">"匹配成功"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"匹配失败"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> match_obj2:</span><br><span class="line">    print(<span class="string">"匹配成功"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"匹配失败"</span>)</span><br></pre></td></tr></table></figure><p>输出:</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610110338290.png" alt="image-20200610110338290"></p><p>使用多个标志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, re.I|re.M)</span><br></pre></td></tr></table></figure><p>对字符串开头的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string1 &#x3D; &quot;he, great&quot;</span><br><span class="line">string2 &#x3D; &quot;he great&quot;</span><br><span class="line">string3 &#x3D; &quot;great&quot;</span><br><span class="line">print(re.match(&#39;gr&#39;, string1))</span><br><span class="line">print(re.match(&#39;gr&#39;, string2))</span><br><span class="line">print(re.match(&#39;gr&#39;, string3))</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610112158212.png" alt="image-20200610112158212"></p><h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p>扫描整个字符串并返回第一个成功的匹配</p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags&#x3D;0)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &#x3D; &quot;great&quot;</span><br><span class="line">print(re.search(&#39;ea&#39;, string))</span><br><span class="line">print(re.search(&#39;gr&#39;, string))</span><br><span class="line"></span><br><span class="line"># 与match函数比较</span><br><span class="line">print(re.match(&#39;ea&#39;, string))</span><br><span class="line">print(re.match(&#39;gr&#39;, string))</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610111344856.png" alt="image-20200610111344856"></p><p>返回对象的group方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'great grass hello grey'</span></span><br><span class="line">search_obj = re.search(<span class="string">r'(.*)rass(.*)'</span>, string)</span><br><span class="line">match_obj = re.match(<span class="string">r'(.*)rass(.*)'</span>, string)</span><br><span class="line"><span class="keyword">if</span> search_obj:</span><br><span class="line">    print(search_obj.group())</span><br><span class="line">    print(search_obj.group(<span class="number">1</span>))</span><br><span class="line">    print(search_obj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No match"</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment"># 与match对象比较</span></span><br><span class="line"><span class="keyword">if</span> match_obj:</span><br><span class="line">    print(match_obj.group())</span><br><span class="line">    print(match_obj.group(<span class="number">1</span>))</span><br><span class="line">    print(match_obj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No match"</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610112932649.png" alt="image-20200610112932649"></p><h3 id="sub函数"><a href="#sub函数" class="headerlink" title="sub函数"></a>sub函数</h3><p>替换字符串中的匹配项</p><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>repl：想要替换成的字符串， 或者为一个函数</li><li>count：替换的最大次数，默认为0，替换所有的匹配</li></ul><p>后两个参数可有可无</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string &#x3D; &#39;128919074391&#39;</span><br><span class="line">str2 &#x3D; re.sub(r&#39;9&#39;, &#39;望&#39;, string)</span><br><span class="line">print(str2)</span><br><span class="line">print(re.sub(r&#39;望&#39;, &#39;9&#39;, str2, 1))</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/image-20200610130804662.png" alt="image-20200610130804662"></p><p>tips：采用sub替换后，string本身并不改变</p><p>rpl作为函数的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(match)</span>:</span></span><br><span class="line">    num = int(match.group(<span class="string">'a'</span>))</span><br><span class="line">    <span class="keyword">return</span> str(num*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string = <span class="string">'ABCD12341324'</span></span><br><span class="line">str2 = re.sub(<span class="string">r'(?P&lt;a&gt;\d+)'</span>, double, string)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure><p>输出:</p><p><code>ABCD24682648</code></p><p>其中<code>?&lt;a&gt;</code>是添加一个组名为’a’的group</p><p>tips: 别忘了正则表达式里的括号</p><h3 id="compile函数"><a href="#compile函数" class="headerlink" title="compile函数"></a>compile函数</h3><p>编译正则表达式，生成一个正则表达式对象</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern, flags)</span><br><span class="line">pattern.match(string, start, end)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</span><br><span class="line">matched1 = pattern.match(<span class="string">'123ABCD456ADBC789'</span>)</span><br><span class="line">matched2 = pattern.match(<span class="string">'123ABCD456ADBC789'</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">matched3 = pattern.match(<span class="string">'123ABCD456ADBC789'</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">print(matched1)</span><br><span class="line">print(matched2)</span><br><span class="line">print(matched3)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span&#x3D;(0, 3), match&#x3D;&#39;123&#39;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span&#x3D;(7, 9), match&#x3D;&#39;45&#39;&gt;</span><br></pre></td></tr></table></figure><p>返回的编译对象的方法：</p><ul><li>group    获得一个或多个分组匹配的字符串</li><li>start      获取某个分组的起始位置</li><li>end        获取某个分组的结束位置</li><li>span      某个分组所在范围</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'([a-z]+) ([a-z]+)'</span>, re.I)</span><br><span class="line">matched = pattern.match(<span class="string">"Hello world hey hi"</span>)</span><br><span class="line">print(matched.group())</span><br><span class="line">print(matched.group(<span class="number">1</span>))</span><br><span class="line">print(matched.end(<span class="number">1</span>))</span><br><span class="line">print(matched.start(<span class="number">1</span>))</span><br><span class="line">print(matched.span(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br><span class="line">Hello</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">(6, 11)</span><br></pre></td></tr></table></figure><h3 id="findall函数"><a href="#findall函数" class="headerlink" title="findall函数"></a>findall函数</h3><p>找到所有匹配的子串</p><p>tips: match 和 search 只匹配一次</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.findall(string, start, end)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'\d+'</span>)</span><br><span class="line">result1 = pattern.findall(<span class="string">'hello12138 hexo 3684'</span>)</span><br><span class="line">result2 = pattern.findall(<span class="string">'hello12138 hexo 3684'</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;12138&#39;, &#39;3684&#39;]</span><br><span class="line">[&#39;12138&#39;]</span><br></pre></td></tr></table></figure><h3 id="finditer"><a href="#finditer" class="headerlink" title="finditer"></a>finditer</h3><p>找到所有匹配的子串，并返回迭代器</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itera = re.finditer(<span class="string">r'\d+'</span>, <span class="string">'abd12134afdasd434as454'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itera:</span><br><span class="line">    print(i)</span><br><span class="line">    print(i.group())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span&#x3D;(3, 8), match&#x3D;&#39;12134&#39;&gt;</span><br><span class="line">12134</span><br><span class="line">&lt;re.Match object; span&#x3D;(14, 17), match&#x3D;&#39;434&#39;&gt;</span><br><span class="line">434</span><br><span class="line">&lt;re.Match object; span&#x3D;(19, 22), match&#x3D;&#39;454&#39;&gt;</span><br><span class="line">454</span><br></pre></td></tr></table></figure><h3 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h3><p>按照匹配的子串将字符串分隔后返回列表</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数：maxsplit    最大分隔次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(re.split(<span class="string">r'\W+'</span>, <span class="string">'runoob, runoob, runoob.'</span>))</span><br><span class="line">print(re.split(<span class="string">r'(\W+)'</span>, <span class="string">' runoob, runoob, runoob.'</span>))</span><br><span class="line">print(re.split(<span class="string">r'\W+'</span>, <span class="string">' runoob, runoob, runoob.'</span>, <span class="number">1</span>))</span><br><span class="line">print(re.split(<span class="string">r'a+'</span>, <span class="string">'hello world'</span>))  <span class="comment"># 对无匹配的字符串不会分隔</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#39;runoob&#39;, &#39;runoob&#39;, &#39;runoob&#39;, &#39;&#39;]</span><br><span class="line">[&#39;&#39;, &#39; &#39;, &#39;runoob&#39;, &#39;, &#39;, &#39;runoob&#39;, &#39;, &#39;, &#39;runoob&#39;, &#39;.&#39;, &#39;&#39;]</span><br><span class="line">[&#39;&#39;, &#39;runoob, runoob, runoob.&#39;]</span><br><span class="line">[&#39;hello world&#39;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2020/06/06/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/06/06/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><p>‘#’代表一级标题, ‘##’代表二级标题, 以此类推，最多可到六级标题 。</p><p>tips: 记得加空格，在markdown语法中很多地方都需要在符号后加一个空格，因此最好养成打完符号后空格的习惯 。</p><h2 id="2、段落"><a href="#2、段落" class="headerlink" title="2、段落"></a>2、段落</h2><p>段落的换行可在段落的末尾打两个空格加回车 ，也可以直接使用一个空行。</p><h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><p>斜体：<code>*文本*</code>或者<code>_文本_</code>,效果：<em>文本</em>    <em>文本</em></p><p>粗体：<code>**文本**</code>或者<code>__文本__</code>，效果：<strong>文本</strong>  <strong>文本</strong></p><p>粗斜体：<code>***文本***</code>或者<code>___文本___</code>， 效果：<strong><em>文本</em></strong>  <strong><em>文本</em></strong></p><h2 id="4、分隔线"><a href="#4、分隔线" class="headerlink" title="4、分隔线"></a>4、分隔线</h2><p>使用<code>***</code>、<code>*****</code>、<code>----------</code></p><p>效果：</p><hr><hr><hr><h2 id="5、删除线"><a href="#5、删除线" class="headerlink" title="5、删除线"></a>5、删除线</h2><p>使用<code>~~文本~~</code>， 效果：<del>文本</del></p><h2 id="6、下划线"><a href="#6、下划线" class="headerlink" title="6、下划线"></a>6、下划线</h2><p>通过HTML的<code>&lt;u&gt;</code>标签实现， 用法：<code>&lt;u&gt;文本&lt;/u&gt;</code>， 效果：<u>文本</u>  </p><h2 id="7、脚注"><a href="#7、脚注" class="headerlink" title="7、脚注"></a>7、脚注</h2><p>创建脚注使用<code>[^文本]</code>， 效果：文字<a href="这是刚刚创建的脚注">^脚注文本</a></p><p>创建完毕后，可在markdown文件的底部写脚注。</p><h2 id="8、列表"><a href="#8、列表" class="headerlink" title="8、列表"></a>8、列表</h2><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用<code>*</code>、<code>+</code>或<code>-</code>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br></pre></td></tr></table></figure><p><code>+</code>和<code>-</code>的用法相同。</p><p>效果：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>使用数字加上<code>.</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="9、列表嵌套"><a href="#9、列表嵌套" class="headerlink" title="9、列表嵌套"></a>9、列表嵌套</h3><p>只需在子列表的选项中添加四个空格或一个Tab键。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">* 第一项的第一个元素</span><br><span class="line">* 第一项的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">* 第二项的第一个元素</span><br><span class="line">* 第二项的第二个元素</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>第一项：<pre><code>* 第一项的第一个元素* 第一项的第二个元素</code></pre></li><li>第二项：<ul><li>第二项的第一个元素<ul><li>第二项的第二个元素</li></ul></li></ul></li></ol><p>其中的<code>*</code>也可换为<code>-</code>或<code>+</code>。</p><h2 id="10、区块"><a href="#10、区块" class="headerlink" title="10、区块"></a>10、区块</h2><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块的第一行</span><br><span class="line">&gt; 区块的第二行</span><br><span class="line">&gt; 区块的第三行</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>区块的第一行<br>区块的第二行<br>区块的第三行</p></blockquote><h2 id="11、区块的嵌套"><a href="#11、区块的嵌套" class="headerlink" title="11、区块的嵌套"></a>11、区块的嵌套</h2><p><strong>区块与区块的嵌套：</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一层</span><br><span class="line">&gt; &gt; 第二层</span><br><span class="line">&gt; &gt; &gt; 第三层</span><br></pre></td></tr></table></figure><p>即不断增加<code>&gt;</code>号，<code>&gt;</code>之间的空格可有可无</p><p>效果：</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote><p>区块中嵌套列表：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 有序列表第一项</span><br><span class="line">&gt; 2. 有序列表第二项</span><br><span class="line">&gt; + 无序列表第一项</span><br><span class="line">&gt; + 无序列表第二项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>有序列表第一项</li><li>有序列表第二项</li></ol><ul><li>无序列表第一项</li><li>无序列表第二项</li></ul></blockquote><p>列表中嵌套区块：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 无序列表第一项</span><br><span class="line">&gt; 区块的第一行</span><br><span class="line">&gt; 区块的第二行</span><br><span class="line">+ 无序列表第二项</span><br><span class="line">&gt; 区块的第一行</span><br><span class="line">&gt; 区块的第二行</span><br><span class="line"></span><br><span class="line">1. 有序列表第一项</span><br><span class="line">&gt; 区块的第一行</span><br><span class="line">&gt; 区块的第二行</span><br><span class="line">2. 有序列表第二项</span><br><span class="line">&gt; 区块的第一行</span><br><span class="line">&gt; 区块的第二行</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><p>无序列表第一项</p><blockquote><p>区块的第一行<br>区块的第二行</p></blockquote></li><li><p>无序列表第二项</p><blockquote><p>区块的第一行<br>区块的第二行</p></blockquote></li></ul><ol><li><p>有序列表第一项</p><blockquote><p>区块的第一行<br>区块的第二行</p></blockquote></li><li><p>有序列表第二项</p><blockquote><p>区块的第一行<br>区块的第二行</p></blockquote></li></ol><h2 id="12、代码"><a href="#12、代码" class="headerlink" title="12、代码"></a>12、代码</h2><p>小的代码片段(无需换行的代码)：</p><p>使用反引号`包裹住代码片段(反引号在键盘中数字1的左边，需使用英文输入模式)。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;print(&quot;Hello world!&quot;)&#96; 你好，世界！</span><br></pre></td></tr></table></figure><p>效果：</p><p><code>print(&quot;Hello world!&quot;)</code>你好，世界！</p><p>代码区块：</p><p>使用三个反引号包裹住代码区块：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>def init():<br>    print(‘Hello world’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def init():</span><br><span class="line">print(&#39;Hello world&#39;)</span><br></pre></td></tr></table></figure><h2 id="13、链接"><a href="#13、链接" class="headerlink" title="13、链接"></a>13、链接</h2><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[snow zhao&#39;s blog](https:&#x2F;&#x2F;snowzhao.tk)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://snowzhao.tk">snow zhao’s blog</a></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;snowzhao.tk&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://snowzhao.tk">https://snowzhao.tk</a></p><p>高级链接：</p><p>使用变量来设置链接，然后在文档末尾设置变量的链接</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[地址名称][变量名]</span><br><span class="line"></span><br><span class="line">文档末尾:</span><br><span class="line">[变量名]: 链接地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[我的博客][blog]</span><br><span class="line"></span><br><span class="line">文档末尾：</span><br><span class="line">[blog]: https:&#x2F;&#x2F;snowzhao.tk</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://snowzhao.tk">我的博客</a></p><h2 id="14、图片"><a href="#14、图片" class="headerlink" title="14、图片"></a>14、图片</h2><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 “标题”)</span><br></pre></td></tr></table></figure><p>属性文本为图片的替代文字，标题可填可不填。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![scenery](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;zhj12138&#x2F;CloudImage@master&#x2F;img&#x2F;221a0d7dbe3e98365133da901ac9deb1cc686ed0981052949ab9f5cf4f1fc94f.jpg)</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3poajEyMTM4L0Nsb3VkSW1hZ2VAbWFzdGVyL2ltZy8yMjFhMGQ3ZGJlM2U5ODM2NTEzM2RhOTAxYWM5ZGViMWNjNjg2ZWQwOTgxMDUyOTQ5YWI5ZjVjZjRmMWZjOTRmLmpwZw?x-oss-process=image/format,png" alt="scenery"></p><p>也可使用<code>&lt;img&gt;</code>标签来实现：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;zhj12138&#x2F;CloudImage@master&#x2F;img&#x2F;221a0d7dbe3e98365133da901ac9deb1cc686ed0981052949ab9f5cf4f1fc94f.jpg&quot; width&#x3D;&quot;100%&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中src的值设为图片地址， width可用于控制图片大小。</p><p>效果：</p><img src="https://cdn.jsdelivr.net/gh/zhj12138/CloudImage@master/img/221a0d7dbe3e98365133da901ac9deb1cc686ed0981052949ab9f5cf4f1fc94f.jpg" width="100%"><h2 id="15、表格"><a href="#15、表格" class="headerlink" title="15、表格"></a>15、表格</h2><p><strong>分隔符</strong>：<code>|</code>用来分隔单元格, <code>-</code>用来分隔表头和其他行</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 | 表头 |</span><br><span class="line">| --- | --- |</span><br><span class="line">| 单元格1 | 单元格2 |</span><br><span class="line">| 单元格3 | 单元格4 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格1</td><td>单元格2</td></tr><tr><td>单元格3</td><td>单元格4</td></tr></tbody></table><p><strong>对齐方式</strong>：</p><p>右对齐：<code>-:</code></p><p>左对齐：<code>:-</code></p><p>居中对齐：<code>:-:</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :---- | ----: | :----: |</span><br><span class="line">| 单元格1| 单元格2| 单元格3 |</span><br><span class="line">| 单元格4| 单元格5| 单元格6 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格1</td><td align="right">单元格2</td><td align="center">单元格3</td></tr><tr><td align="left">单元格4</td><td align="right">单元格5</td><td align="center">单元格6</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言易错点</title>
      <link href="/2020/06/06/C%E8%AF%AD%E8%A8%80%E6%98%93%E9%94%99%E7%82%B9/"/>
      <url>/2020/06/06/C%E8%AF%AD%E8%A8%80%E6%98%93%E9%94%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言易错点"><a href="#C语言易错点" class="headerlink" title="C语言易错点"></a>C语言易错点</h1><p>1.sizeof是关键字而非函数。<br>     2.定义变量时，不能同时对多个变量连续赋初始值。<br>        eg：int m=n=1；//错误<br>     3.scanf语句：<br>       “%c”将读入空白符，”  %c”能忽略空白符。<br>        “%s”遇到空白符读入结束。<br>        ps：要想将有空格的字符串存入char型数组中，可使用gets(str) 或fgets(str,size,stdin)从标准输入设备中读入。但不建议使 用危险的gets(str),因为它无法限制输入字符串的长度，容易导致缓冲区溢出。两者的读入有所区别，fgets()读入换行符会将换行符作为字符串的一部分。<br>        scanf语句中没有精度修饰符。<br>        scanf语句输入数值时，读入结束的几种情况：<br>        1）遇到空白符<br>        2）达到域宽<br>        3）遇到非法输入<br>        scanf语句的返回值为读入的项数。未能成功读入返回0，调用函数失败或读到文件结束返回EOF(值为-1的宏)。<br>     4.小心&amp;&amp;与||的短路特性。<br>        eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b++&gt;<span class="number">2</span>)<span class="comment">//b++不会被执行</span></span><br><span class="line">a+=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>   5.空指针不能解引用。<br>     6.函数的返回值可以是除了数组之外的任何类型。<br>     7.数组名是一个地址，不能改变。<br>        eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(a+<span class="number">1</span>));<span class="comment">//合法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(++a));<span class="comment">//不合法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p);<span class="comment">//合法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(++p));<span class="comment">//合法</span></span><br></pre></td></tr></table></figure><p>   8.共用体不能进行比较操作，也不能作为函数参数。<br>   9.局部变量可以屏蔽全局变量(就近原则)。<br>   10.同一个外部变量名在两个不同的文件中被声明为不同的类型，会导致C程序失效。<br>     11.使用宏定义完成类似函数的功能时，要注意括号的使用。<br>         eg：<code>#define cube(a)   a*a*a//不好</code><br>         当函数中调用cube(a+b)时，计算的将是<code>(a+(b*a)+(b*a)+b)</code>的<br>         值。<br>         改进：<code>#define cube  ((a)*(a)*(a))</code></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的基本操作</title>
      <link href="/2020/06/06/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/06/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构学习-Unit3栈与队列-栈"><a href="#数据结构学习-Unit3栈与队列-栈" class="headerlink" title="数据结构学习-Unit3栈与队列-栈"></a>数据结构学习-Unit3栈与队列-栈</h1><p>   栈是一种重要的线性结构，具有后进先出的特性。元素只能从栈顶端压入，也只能从栈顶端弹出。</p><p>   我们先来看栈的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stac</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> *bottom;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><p>top即栈顶，位置比最上方元素位置高一位。<br>bottom即栈底，位置指向最下方元素。<br>当栈为空时，有top==bottom</p><p>   栈有以下几种常用操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span></span>;<span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(Stack &amp;S)</span></span>;<span class="comment">//摧毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearStack</span><span class="params">(Stack &amp;S)</span></span>;<span class="comment">//清空栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack S)</span></span>;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(Stack S)</span></span>;<span class="comment">//求栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTop</span><span class="params">(Stack S,<span class="keyword">int</span> &amp;e)</span></span>;<span class="comment">//取得栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack &amp;S,<span class="keyword">int</span> e)</span></span>;<span class="comment">//压入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack &amp;S,<span class="keyword">int</span> &amp;e)</span></span>;<span class="comment">//弹出元素</span></span><br></pre></td></tr></table></figure><p>栈的初始化的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span><span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    S.bottom=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(S.bottom==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>)；</span><br><span class="line">    S.top=S.bottom;</span><br><span class="line">    S.stacksize=SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压入元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack &amp;S,<span class="keyword">int</span> e)</span><span class="comment">//压入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.bottom&gt;=SIZE)<span class="comment">//栈满的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        S.bottom=(<span class="keyword">int</span> *)<span class="built_in">realloc</span>(S.bottom,(ADD_SIZE+S.stacksize)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span>(S.bottom==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        S.top=S.bottom+S.stacksize;</span><br><span class="line">        S.stacksize=S.stacksize+ADD_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++=e;<span class="comment">//top指向的位置的值改为e，然后top位置上升1位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弹出元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack &amp;S,<span class="keyword">int</span> &amp;e)</span><span class="comment">//弹出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.bottom)<span class="comment">//栈为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e=*--S.top;<span class="comment">//top位置下降一位，指向栈中最上方元素，再把该元素的值赋给e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取得栈顶元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTop</span><span class="params">(Stack S,<span class="keyword">int</span> &amp;e)</span><span class="comment">//返回栈顶元素(不同于Pop()函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    e=*(S.top<span class="number">-1</span>);<span class="comment">//注意对比Pop函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摧毁栈：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(Stack &amp;S)</span><span class="comment">//摧毁栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S.bottom);</span><br><span class="line">    S.top=<span class="literal">NULL</span>;</span><br><span class="line">    S.bottom=<span class="literal">NULL</span>;</span><br><span class="line">    S.stacksize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈的清空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearStack</span><span class="params">(Stack &amp;S)</span><span class="comment">//清空栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.top=S.bottom;<span class="comment">//其余的元素不需要做处理，因为压入元素时会自动覆盖原数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈是否为空：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack S)</span><span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//1表示空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0表示非空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top-S.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇</title>
      <link href="/2020/06/06/%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2020/06/06/%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<pre><code>贪吃蛇小游戏</code></pre><p>   刚学完C语言写的第一个小游戏，代码主要参考：<br><a href="https://blog.csdn.net/qq_37074040/article/details/54766680" target="_blank" rel="noopener">https://blog.csdn.net/qq_37074040/article/details/54766680</a><br>我在模仿代码的过程中发现了原作者程序中的一些bug，以下f附有我加以改进后的代码。</p><p>1.游戏界面<br>楼主认为这个小游戏游戏界面的核心在于光标的控制。只要我们能让光标到达我们想要的地方，我们就能完成游戏界面的绘制，蛋的生成。简直就像天上地下，无所不能。<br>实现:gotoxy()函数</p><p> 2.游戏体验感<br>如何将用户的输入读入，而不显示在屏幕上？<br>实现：getch()函数（包含在&lt;conio.h&gt;中）<br>如何防止用户的非法输入？玩游戏的过程中难免会摁到其他的键，如何让它不影响到我们的游戏？如果蛇在往前行走，我们控制方向向后，该怎么处理？<br>实现:保存蛇的前进状态。</p><p> 3.游戏关键<br> 蛇该如何打印？如何实现蛇的行走？<br> 如何完成吃蛋的过程？<br> 游戏结束的条件是什么？<br> 这几个问题都是实现游戏的关键步骤，但是实际操作起来并没有想象中的那么难，希望读者结合下文代码自行思考。</p><p>代码还可以大幅度优化，读者可以自行思考。</p><p>如果发现代码有bug，欢迎下方留言。</p><p>如果觉得楼主的代码对你有帮助的话，可以点个关注，点个赞，谢谢！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> frame_height 30<span class="comment">//地图尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> frame_width 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UP <span class="meta-string">'w'</span><span class="comment">//移动</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOWN <span class="meta-string">'s'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT <span class="meta-string">'a'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT <span class="meta-string">'d'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i,j,k,sp,score;</span><br><span class="line"><span class="keyword">char</span> ch=UP,state=UP,choo,n;<span class="comment">//初始化方向</span></span><br><span class="line"><span class="keyword">int</span> grow=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Food</span>//食物</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">&#125; food;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span>//蛇</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*用数组储存蛇的每一部分的坐标*/</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> y[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">int</span> speed;<span class="comment">//速度</span></span><br><span class="line">&#125; snake;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_food</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//更新食物</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_snake</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//蛇的移动</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alive</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//判断蛇是否死亡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_speed</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//更新速度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//移动光标，进行游戏界面的打印</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        score=<span class="number">0</span>;<span class="comment">//初始化分数为0</span></span><br><span class="line">        <span class="comment">/*让用户进行难度选择，有彩蛋*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Choose the degree of difficulty:\n1:easy\t2:middle  3:difficult\n"</span>);</span><br><span class="line">        n=getch();</span><br><span class="line">        <span class="keyword">switch</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sp=<span class="number">300</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sp=<span class="number">230</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sp=<span class="number">180</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Congratulations!Welcome to Devil's difficulty\n"</span>);</span><br><span class="line">            sp=<span class="number">120</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"cls"</span>);<span class="comment">//每次新一局游戏先清屏,包含在&lt;stdlib.h&gt;</span></span><br><span class="line">        <span class="built_in">map</span>();<span class="comment">//打印地图</span></span><br><span class="line">        <span class="comment">/*开始游戏*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            update_food();<span class="comment">//生产食物</span></span><br><span class="line">            get_speed();<span class="comment">//获取速度</span></span><br><span class="line">            move_snake();<span class="comment">//移动</span></span><br><span class="line">            Sleep(snake.speed);<span class="comment">//延时函数,speed数值越大延时越长</span></span><br><span class="line">            <span class="keyword">if</span>(!(alive()))<span class="comment">//判断蛇是否死亡</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//死亡则退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game Over!\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1:Restart\t2:exit"</span>);</span><br><span class="line">        choo=getch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(choo==<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">/*打印第一个食物*/</span></span><br><span class="line">    <span class="comment">/*Attention!此处留了一个bug:可能食物</span></span><br><span class="line"><span class="comment">    的位置与初始的蛇重合，然后食物就会消</span></span><br><span class="line"><span class="comment">    失，读者可以加以改进*/</span></span><br><span class="line">    food.x=rand()%(frame_height<span class="number">-2</span>)+<span class="number">1</span>;</span><br><span class="line">    food.y=rand()%(frame_width<span class="number">-2</span>)+<span class="number">1</span>;<span class="comment">//在框内</span></span><br><span class="line">    gotoxy(food.x,food.y);<span class="comment">//把光标移动到该坐标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"$"</span>);<span class="comment">//打印食物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*snake的初始化*/</span></span><br><span class="line">    snake.x[<span class="number">0</span>]=frame_height/<span class="number">2</span>;</span><br><span class="line">    snake.y[<span class="number">0</span>]=frame_width/<span class="number">2</span>;</span><br><span class="line">    gotoxy(snake.x[<span class="number">0</span>],snake.y[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"@"</span>);</span><br><span class="line">    snake.len=<span class="number">3</span>;</span><br><span class="line">    snake.speed=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;snake.len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        snake.x[k]=snake.x[k<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        snake.y[k]=snake.y[k<span class="number">-1</span>];</span><br><span class="line">        gotoxy(snake.x[k],snake.y[k]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*墙壁*/</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;frame_width; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        gotoxy(<span class="number">0</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">        gotoxy(frame_height<span class="number">-1</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;frame_height<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gotoxy(i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">        gotoxy(i,frame_width<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gotoxy(<span class="number">2</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="string">'1'</span>) <span class="built_in">printf</span>(<span class="string">"Difficulty:   easy"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">'2'</span>) <span class="built_in">printf</span>(<span class="string">"Difficulty:   middle"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">'3'</span>) <span class="built_in">printf</span>(<span class="string">"Difficulty:   difficult"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Welcome to the Devil's difficulty"</span>);</span><br><span class="line">    gotoxy(<span class="number">4</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"UP:   w"</span>);</span><br><span class="line">    gotoxy(<span class="number">6</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"DOWN: s"</span>);</span><br><span class="line">    gotoxy(<span class="number">8</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LEFT: a"</span>);</span><br><span class="line">    gotoxy(<span class="number">10</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"RIGHT:d"</span>);</span><br><span class="line">    gotoxy(<span class="number">12</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Your score:%d"</span>,score);</span><br><span class="line">    gotoxy(<span class="number">28</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Made by Zhao Hejie"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*食物*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_food</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(snake.x[<span class="number">0</span>]==food.x&amp;&amp;snake.y[<span class="number">0</span>]==food.y)<span class="comment">//吃到食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        score+=<span class="number">10</span>;</span><br><span class="line">        gotoxy(<span class="number">12</span>,frame_width+<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Your score:%d"</span>,score);</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="comment">/*以下是更新食物的代码,里面排除了</span></span><br><span class="line"><span class="comment">        食物与蛇重合的情况,读者可以参考以</span></span><br><span class="line"><span class="comment">        下代码完成对上述bug的改进*/</span></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//标记变量</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">        food.x=rand()%(frame_height<span class="number">-2</span>)+<span class="number">1</span>;</span><br><span class="line">        food.y=rand()%(frame_width<span class="number">-2</span>)+<span class="number">1</span>;<span class="comment">//在框内</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;snake.len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(food.x==snake.x[i]&amp;&amp;food.y==snake.y[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">0</span>;<span class="comment">//有重合</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(flag==<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*打印食物*/</span></span><br><span class="line">        gotoxy(food.x,food.y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"$"</span>);</span><br><span class="line">        snake.len++;</span><br><span class="line">        grow=<span class="number">1</span>;<span class="comment">//表明长了，在move_snake函数中有用到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*移动蛇*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_snake</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(kbhit())<span class="comment">//键盘有输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch=getch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!grow)<span class="comment">//没有长</span></span><br><span class="line">    &#123;</span><br><span class="line">        gotoxy(snake.x[snake.len<span class="number">-1</span>],snake.y[snake.len<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);<span class="comment">//走了，在数组的最后打印空格，清除原有的蛇尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=snake.len<span class="number">-1</span>; k&gt;<span class="number">0</span>; k--)<span class="comment">//更新蛇的坐标，除了蛇头,其余位置继承上一个点的坐标</span></span><br><span class="line">    &#123;</span><br><span class="line">        snake.x[k]=snake.x[k<span class="number">-1</span>];</span><br><span class="line">        snake.y[k]=snake.y[k<span class="number">-1</span>];<span class="comment">//移动位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(ch)<span class="comment">//改变方向</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> UP:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state==DOWN)<span class="comment">//如果此时方向向下，输入向上的作用要被无视</span></span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]--;</span><br><span class="line">            state=UP;<span class="comment">//其余的改变状态为向上</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state==UP)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]++;</span><br><span class="line">            state=DOWN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state==RIGHT)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]--;</span><br><span class="line">            state=LEFT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state==LEFT)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]++;</span><br><span class="line">            state=RIGHT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*摁其余键,保持原有状态*/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(state==DOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state==UP)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.x[<span class="number">0</span>]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state==LEFT)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state==RIGHT)</span><br><span class="line">        &#123;</span><br><span class="line">            snake.y[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gotoxy(snake.x[<span class="number">0</span>],snake.y[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"@"</span>);<span class="comment">//打印蛇头</span></span><br><span class="line">    grow=<span class="number">0</span>;<span class="comment">//初始成长状态为0</span></span><br><span class="line">    gotoxy(frame_height,<span class="number">0</span>);<span class="comment">//光标移动到地图左下角下方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*存活状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alive</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(snake.x[<span class="number">0</span>]==<span class="number">0</span>||snake.x[<span class="number">0</span>]==frame_height<span class="number">-1</span>||snake.y[<span class="number">0</span>]==<span class="number">0</span>||snake.y[<span class="number">0</span>]==frame_width<span class="number">-1</span>)<span class="comment">//撞墙</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;snake.len; k++) <span class="comment">//咬到自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(snake.x[<span class="number">0</span>]==snake.x[k]&amp;&amp;snake.y[<span class="number">0</span>]==snake.y[k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加速*/</span></span><br><span class="line"><span class="comment">/*speed越大,蛇的速度越小*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_speed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(snake.len&lt;=<span class="number">6</span>)</span><br><span class="line">        snake.speed=sp;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(snake.len&lt;=<span class="number">10</span>)</span><br><span class="line">        snake.speed=sp<span class="number">-20</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(snake.len&lt;=<span class="number">20</span>)</span><br><span class="line">        snake.speed=sp<span class="number">-50</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(snake.len&lt;=<span class="number">30</span>)</span><br><span class="line">        snake.speed=sp<span class="number">-60</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        snake.speed=sp<span class="number">-70</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*移动光标*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hout;</span><br><span class="line">    COORD cor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    typedef struct _COORD</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        SHORT X; // horizontal coordinate</span></span><br><span class="line"><span class="comment">        SHORT Y; // vertical coordinate</span></span><br><span class="line"><span class="comment">    &#125; COORD;</span></span><br><span class="line"><span class="comment">    用该结构体来储存坐标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    hout=GetStdHandle(STD_OUTPUT_HANDLE);<span class="comment">//从标准输出设备中取得一个句柄</span></span><br><span class="line">    <span class="comment">/*这其中x,y的赋值对象要注意,不懂的好好想想*/</span></span><br><span class="line">    cor.X=y;</span><br><span class="line">    cor.Y=x;</span><br><span class="line">    SetConsoleCursorPosition(hout,cor);<span class="comment">//定位光标的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> games </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
